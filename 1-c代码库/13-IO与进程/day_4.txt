【1】exit和_exit
 _exit()函数的作用最为简单：直接使进程终止运行，清除其使用的内存空间，并销毁其在内核中的各种数据结构；

 exit()函数则在这些基础上作了一些包装,刷新缓冲区
 
 1）exit和return
   exit属于系统级别，功能使调用进程退出，释放资源 
   return属于函数返回，并不能使进程退出，只是返回一个值，当return出现在main中，此时return表示将0返回给
   父进程，以此表示进程退出，当return出现在子函数中，表示将返回的值给主函数
   
   当进程代码执行完毕之后，会隐式调用exit将进程退出
   
【2】daemon守护进程的创建
    1）创建子进程，父进程退出 
	   使子进程成为孤儿进程，脱离父进程，成为init进程的子进程

    2）在子进程中创建新会话 
	   setsid   功能：创建新会话，并且是调用进程成为会话组组长
	   setsid:  让进程摆脱原会话的控制; 
	            让进程摆脱原进程组的控制; 
				让进程摆脱原控制终端的控制

    3）改变当前目录为根目录 
       chdir("/");
    4）重设文件权限掩码 
	   umask(0)
       由于使用fork新建的子进程继承了父进程的文件权限掩码,子进程成为守护进程，他需要对文件操作时
	   获取文件的最大权限
    5）关闭文件描述符 
	   for (fd = 0; fd < getdtablesize(); fd++）
	   　　close(fd); 
       关闭子进程从父进程继承的所有的文件描述符
【3】线程
  在同一个进程中创建的线程共享该进程的地址空间
  
  一个进程可以创建多个线程，线程与线程之间共享进程虚拟地址空间，共享进程数据段，程序文本段，堆区，每一个线程都有
  属于自己的栈区，保存自己的局部变量，控制线程中使用的函数的调用以及返回
  
  线程：进程并发执行多个任务的一种机制
  
  线程与进程：
      进程是独立的，每一个享有自己的独立的虚拟地址空间，进程与进程之间没有任何联系，如果进程之间想要建立联系，
	  需要进程的通信机制
	  线程是共享进程的资源，线程之间进行交互，通过操作全局变量进行通信，任何时刻需要保证只有一个线程操作同一个全局变量
	  因此线程间通信需要引入同步互斥机制，用来保证在任意时刻，线程不争抢共有资源
	  
	  进程的创建通过fork完成，创建进程需要复制父进程的几乎所有的属性
	  线程的创建不需要复制任何属性，线程之间通过共享资源完成，线程的创建比进程的创建要快
	  
【3】线程的创建以及控制
      线程的创建：
      创建线程
      线程退出
      控制线程

	  线程间同步和互斥机制：
	  信号量
	  互斥锁
      条件变量
	  
	函数原型：int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);
	功能：创建一个新的线程在进程中
	参数：thread  线程的标识符（ID）
	      attr    线程的属性   默认为NULL
		  start_routine   线程的执行函数
		  arg   参数传递给第三个参数
	返回值：成功   0
	        失败   错误码
			
	函数原型：void pthread_exit(void *retval);
	功能：退出线程
	参数：retval   可被pthread_join回收
	
	函数原型：int pthread_join(pthread_t thread, void **retval);
	功能：回收线程退出时的所占用的资源
	参数：thread   线程的标识符
	      retval   保存pthread_exit的参数
		  
		  
【4】互斥锁
 互斥锁机制：保证线程执行操作的完整性
             不保证线程的执行先后，哪个线程上锁完成，哪个线程执行对全局数据的操作

          	 当多个线程对同一个共享资源进行操作时，有一个线程执行上锁解锁操作，另外其他线程必须执行
             上锁解锁操作			 
 函数原型：int pthread_mutex_init(pthread_mutex_t *restrict mutex,
              const pthread_mutexattr_t *restrict attr);
 功能：初始化互斥锁
 参数：mutex    互斥锁标识符
       attr     互斥锁的属性，默认为NULL，执行默认属性
 返回值：成功    0
         失败    错误码
		 
 函数原型：int pthread_mutex_lock(pthread_mutex_t *mutex);
 功能：执行上锁操作，如果互斥锁已被使用，阻塞等待互斥锁被释放
 参数：mutex  互斥锁标识符
 返回值：成功   0
         失败   错误码

 函数原型： int pthread_mutex_unlock(pthread_mutex_t *mutex);
 功能：释放锁（解锁）
 参数：mutex  互斥锁标识符
 返回值：成功   0
         失败   错误码
		 
 函数原型：int pthread_mutex_destroy(pthread_mutex_t *mutex);
 功能：摧毁互斥锁
 参数：mutex  互斥锁标识符
 返回值：成功   0
         失败  错误码
		 
 死锁：
      1）交叉死锁（互斥锁嵌套）
	  2）重复上锁（一个线程在没有释放锁的时候，不能重复对同一个互斥锁再从执行上锁操作）
	  3）多个线程对同一把锁，进行上锁操作，某一线程上锁成功，收到信号，将线程异常退出，互斥锁资源不会释放
	     导致其他线程不能执行上锁
		 
【5】信号量

 信号量是一个受保护的变量，只能通过三种操作来访问
  初始化
  Ｐ操作(申请资源)
  Ｖ操作(释放资源)

 函数原型：int sem_init(sem_t *sem, int pshared, unsigned int value);
 功能：初始化信号量
 参数：sem   信号量的标识符
       pshared     0    信号量被用于线程之间    
	              非0   信号量被用于进程之间
	   value  信号量的值
 返回值：成功  0
         失败  -1
		 
 函数原型： int sem_wait(sem_t *sem);
 功能：申请信号量资源（申请成功，信号量的值减1）
 参数：sem  信号量的标识符
 返回值：成功   0
         失败   -1

 函数原型：	int sem_post(sem_t *sem);	
 功能：释放信号量资源（释放资源成功，信号量的值加1）
 参数：sem  信号量的标识符
 返回值： 成功  0
          失败  -1
		  
 函数原型：int sem_destroy(sem_t *sem);
 功能：摧毁信号量
 参数：sem  信号量的标识符
 返回值： 成功  0
          失败  -1
 
 函数原型：int sem_getvalue(sem_t *sem, int *sval);
 功能：获取当前信号量的值
 返回值：成功  0
         失败  -1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
 
 

		 
		 

 


		  
		  
		  
	      
	

	  

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

