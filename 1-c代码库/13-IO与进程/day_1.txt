【1】IO---输入输出
 对文件的读写方式：标准IO
                   文件IO
 标准IO：采用库函数的方式对文件进行操作
 文件IO：采用系统调用的方式对文件进行操作
 
 系统调用：内核提供接口层（本身不属于内核，通过内核函数实现），用户程序通过此接口是实现内核为我们写好的功能
 
 系统调用：
 
 封装函数------>系统调用接口------>系统调用例程------->系统调用服务例程（内核函数）
 
 1）系统调用处理器状态的转换
    处理器由用户态（特权级 3）转换为内核态（特权级 0），提高处理器执行的级别，访问到内核中内存
 2）每一个系统调用对应一个编号   
 3）系统调用传参
    普通函数传参将参数通过堆栈去完成
	
 系统调用接口：将系统调用编号写入到寄存器，通过软中断进入到内核空间，将参数保存CPU的寄存器
 系统调用例程：通过系统调用编号找到相应的内核函数，在执行系统调用服务例程之前，将参数从寄存器中取出，放到内核堆栈区
 
 文件IO缺陷：
     不能满足用户程序的需求
	 可移植性差
	 

 标准IO：在用户空间创建缓冲区，当对文件进行读写时，先读写缓冲区，当时机满足时，在进行实际的文件读写，以此减少
         系统调用次数，提高对文件读写效率
		 

【2】标准IO的操作核心
 流：标准I/O库的所有操作都是围绕流(stream)来进行的，在标准I/O中，流用FILE *来描述。
 
 FILE:每个被使用的文件都在内存中开辟一个区域，用来存放文件的有关信息，这些信息是保存在一个结构体类型的变量中，
     该结构体类型是由系统定义的，取名为FILE。
	 （FILE 描述文件属性信息的结构体，由系统定义）
 
 函数原型： FILE *fopen(const char *path, const char *mode);
 功能：打开一个文件
 参数：path   文件名
       mode   r     用只读的方式（权限）打开一个文件，如果文件不存在，报错，文件必须存在
	          r+    用读写的方式（权限）打开一个文件，如果文件不存在，报错，文件必须存在
			  
			  w     用只写的方式打开一个文件，如果文件不存在，创建；如果文件存在，清空文件的数据
			  w+    用读写的方式打开一个文件，如果文件不存在，创建；如果文件存在，清空文件的数据
			  
			  a     用只写的方式打开一个文件，如果文件不存在，创建；如果文件存在，追加到文件末尾
			  a+    用读写的方式打开一个文件，如果文件不存在，创建；如果文件存在，追加到文件末尾
 返回值：   成功   stream  流（描述打开文件属性信息的结构体指针）
            失败   NULL
			

 函数原型：void perror(const char *s);
 功能：打印系统错误消息
 
 函数原型：char *strerror(int errnum);
 功能：描述错误码对应消息
 
【3】标准IO读写操作
 1）采用字符的形式
 3）采用二进制流的形式
 
 函数原型：int fputc(int c, FILE *stream);
 功能：向文件中写入一个字符
 参数：c   写入的字符
       stream  指定的流（文件）
 返回值：成功   写入的字符
         失败   EOF  
		 
 函数原型： int fgetc(FILE *stream);
 功能：从文件中读取一个字符
 参数：stream  指定的流（文件）
 返回值:  成功   读取的字符
          失败   EOF
		  
 
 标准I/O预定义3个流，他们可以自动地为进程所使用（默认操作终端）
 
     1）标准输入流指针            stdin
	 2）标准输出流指针            stdout
	 3）标准出错输出流指针        stderr
	 
	 

 缓冲区类型：
 1）全缓冲----当流与文件相关联的时候，此时操作的缓冲区就是全缓冲
              FP  （4K）
    全缓冲刷新条件： 程序正常退出
	                 缓冲区满
					 fflush（fp） 强制刷新
 2）行缓冲----当流与终端相关联的时候，此时操作的缓冲区就是行缓冲
              STDIN  STDOUT  （1K）
    行缓冲区刷新条件：程序正常退出
	                  缓冲区满
					  fflush（fp） 强制刷新
					  "\n"
 3）不缓冲----没有缓冲区
              stderr
			  
			 
 流的读写位置定位：
 函数原型： int fseek(FILE *stream, long offset, int whence);
 功能：定位流的读写位置
 参数：stream  指定的流（文件）
       offset  偏移量  
       whence  SEEK_SET  将读写位置定位到文件的开始处
               SEEK_CUR  将读写位置定位到当前的位置
               SEEK_END  将读写位置定位到文件的末尾
 返回值：   成功   0
            失败   -1
			
 函数原型： long ftell(FILE *stream);
 功能：获取流当前的读写位置
 参数：stream  指定的流（文件）
 返回值：   成功  当前的读写位置
            失败  -1
			


 2）采用读写字符串的形式
 
 函数原型：int fputs(const char *s, FILE *stream);
 功能：写字符串到文件中
 参数：s   写入的字符串
       stream 指定的流（文件）
 返回值：成功  非负数
         失败  EOF
		 
 函数原型： char *fgets(char *s, int size, FILE *stream);
 功能：从文件中读取字符串（最多读取size -1）
 参数：s   数据保存的位置
       size   字符的个数
	   stream  指定的流（文件）
 返回值：成功  读取的字符串
         失败  NULL
		 
		 
 (1)当文件中的字符的个数  >=  N     fgets只能读取N - 1字符，fgets在执行时，在字符串的末尾加‘\0’结束符
                                 表示字符串到此读取结束
								 
 (2)当文件中的字符的个数  <   N     fgets读取到文件中所有的字符，并且在字符串的末尾加‘\0’
 
  N == 3， 文件：abcde
  fgets-------> ab'\0'
  
  N == 6， 文件：abcde    (文件中没有'\n')          
  fgets-------> abcde'\0'
  
  N == 12， 文件：abcde'\n'    (文件中有'\n')         
  fgets-------> abcde'\n''\0'
  
 
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   

		 
 
 
 
 
 